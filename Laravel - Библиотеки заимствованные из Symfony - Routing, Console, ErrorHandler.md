Можно рассмотреть зависимости в [composer.json](https://github.com/laravel/framework/blob/10.x/composer.json) файле репозитория [laravel/framework](https://github.com/laravel/framework). Все библиотеки в секциях `require` и `require-dev`  начинающиеся с 
`symfony/` - это библиотеки взятые из Symphony. Их можно использовать в своих PHP проектах, куда нет надобности или желания тащить фреймворк целиком. Например blog.ddaniel.ru, сделан с помощью `symfony/routing` без использования фреймворков.
## Symfony\\Component\\Routing - symfony/routing
Роутинг состоит из нескольких классов:
- `Route`  - Класс для описания одного роута. Его конструктор принимает в себя 8 параметров, но все разом маловероятно понадобятся, поэтому удобно в конструкторе использовать [именованные аргументы](https://www.php.net/manual/en/functions.arguments.php#functions.named-arguments)
- `RouteCollection` - Класс для сбора роутов в него, с помощью метода `add` можно добёавлять в коллекцию роуты
- `RequestContext` - Работает с информацией о текущем запросе, только при создании ее сперва нужно передать в конструктор.  У меня обычно это выглядит вот так `new RequestContext( $_SERVER['REQUEST_URI'], $_SERVER['REQUEST_METHOD'] )`
- `UrlMatcher` - Класс, который в конструкторе принимает `RouteCollection` и `RequestContext` и с помощью метода `match` возвращает подходящий роут или выбрасывает исключение `ResourceNotFoundException`
В сумме эти 4 класса позволяют создать в PHP приложении простой роутинг. Но данная библиотека в ключает в себя еще множество классов, которые нужно обсуждать уже отдельно
## Symfony\\Component\\Console - symfony/console
Для создания собственной консольной команды, нужно создать свой класс наследуемый от `Symfony\Component\Console\Command\Command` и переопределить минимальный набор свойств и методов:
`Command::$defaultName` - имя команды. Можно использовать двоеточие для создания системы неймспейсов и объединения команд, например `config:clear`
`Command::configure` - конфигурирование команды, здесь можно задать имя, описание аргументы
`Command::execute` - выполнение команды. На вход получает два параметра типа `InputInterface` и `OutputInterface`. Названия говорящие, первый отвечает за входные данные и из него можно получить значения переданных аргументов, второй отвечает за вывод данных в консоль с помощью методов `write` и `writeln` 
Все созданные команды должны быть добавлены в `Symfony\Component\Console\Application` и после можно запускать консольное приложение:
```php
$application = new Application();  
$application->add(new TestConsole());  
$application->run();
```
## Symfony\\Component\\ErrorHandler - symfony/error-handler
В Symfony и соответственно в Laravel есть великолепная страница с выводом текущей ошибки. Вместо банального сообщения об ошибке, выводится полноценная html страница с максимально полной информацией об ошибке и стектрейсом в удобном формате. Для включения дебаг режима нужно только вызвать метод `Symfony\Component\ErrorHandler\Debug::enable()` после этого будет зарегистрирован обработчик исключительных ситуаций. 
